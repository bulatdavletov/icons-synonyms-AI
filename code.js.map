{
  "version": 3,
  "sources": ["src/icon-exporter.ts", "src/api-keys.ts", "src/prompt-templates.ts", "src/ai-service.ts", "code.ts"],
  "sourcesContent": ["// Icon Exporter utility for converting Figma icons to images\n\n/**\n * Exports a Figma node as a PNG image and returns it as a base64 string\n * @param node The Figma node to export\n * @param options Export options\n * @returns Promise resolving to a base64-encoded PNG\n */\nexport async function exportNodeAsBase64(\n  node: SceneNode, \n  options: { scale?: number, format?: 'PNG' | 'JPG' | 'SVG' } = {}\n): Promise<string> {\n  try {\n    // Set default options\n    const scale = options.scale || 2; // 2x scale for better quality\n    const format = options.format || 'PNG';\n    \n    // Set export settings\n    const settings: ExportSettings = {\n      format: format as \"PNG\" | \"JPG\" | \"SVG\" | \"PDF\",\n      constraint: { type: 'SCALE', value: scale }\n    };\n    \n    // Get the export data\n    const bytes = await node.exportAsync(settings);\n    \n    // Convert to base64\n    const base64 = figma.base64Encode(bytes);\n    \n    return base64;\n  } catch (error) {\n    console.error('Error exporting node:', error);\n    throw new Error('Failed to export icon');\n  }\n}\n\n/**\n * Optimizes an icon node for export\n * @param node The icon node to optimize\n * @returns The optimized node\n */\nexport function optimizeIconForExport(node: SceneNode): SceneNode {\n  // If the node is a component instance, get its main component\n  if (node.type === 'INSTANCE') {\n    // For instances, we can use the main component for better quality\n    const mainComponent = node.mainComponent;\n    if (mainComponent) {\n      return mainComponent;\n    }\n  }\n  \n  // For other node types, just return the node itself\n  return node;\n}\n\n/**\n * Gets the best node to export from a selection\n * @param selection The current selection\n * @returns The best node to export, or null if no suitable node is found\n */\nexport function getBestNodeToExport(selection: readonly SceneNode[]): SceneNode | null {\n  if (selection.length === 0) {\n    return null;\n  }\n  \n  // If there's only one node selected, use that\n  if (selection.length === 1) {\n    return optimizeIconForExport(selection[0]);\n  }\n  \n  // If multiple nodes are selected, try to find the best one\n  // Prefer components over instances over other node types\n  const components = selection.filter(node => node.type === 'COMPONENT');\n  if (components.length > 0) {\n    return optimizeIconForExport(components[0]);\n  }\n  \n  const instances = selection.filter(node => node.type === 'INSTANCE');\n  if (instances.length > 0) {\n    return optimizeIconForExport(instances[0]);\n  }\n  \n  // If no components or instances, just use the first node\n  return optimizeIconForExport(selection[0]);\n} ", "// API keys for external services\n// This file should not be committed to version control\n\n// OpenAI API key\nexport const OPENAI_API_KEY = \"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\"; ", "// Prompt template for AI service\n\n/**\n * Generate a prompt for icon synonym generation\n * @param iconName The name of the icon\n * @param existingDescription The existing description of the icon (if any)\n * @returns A formatted prompt string\n */\nexport function getIconSynonymsPrompt(iconName: string, existingDescription?: string): string {\n  return `\n    This is an icon named \"${iconName}\". \n    ${existingDescription ? `It currently has this description: \"${existingDescription}\"` : ''}\n    Please generate relevant synonyms or related terms that would help users find this icon when searching.\n    Context: these icons are used in JetBrains IDEs.\n    If name contain several words, use them as separate entities: moveToRightTop = move to right top. It increases the chance to find the icon.\n    Describe the object from the image: trash bin, folder, heart, etc.\n    Describe usual meaning of the object: delete, save, like, etc.\n    Describe shapes that you see: circle, square, rectangle, arrow, etc.\n    Don't use words like \"icon\", \"symbol\", \"image\", etc.\n    Don't repeat the name of icon or existing description.\n    Return only a JSON array of strings with no additional text.\n  `;\n} ", "// AI Service for handling OpenAI integration\nimport { OPENAI_API_KEY } from './api-keys';\nimport { getIconSynonymsPrompt } from './prompt-templates';\n\ninterface OpenAIResponse {\n  synonyms: string[];\n  error?: string;\n}\n\ninterface IconData {\n  name: string;\n  imageBase64: string;\n  existingDescription?: string;\n}\n\n// Use imported API key from separate file that's gitignored\nconst HARDCODED_API_KEY = OPENAI_API_KEY;\n\nexport async function generateSynonyms(iconData: IconData, apiKey: string = \"\"): Promise<OpenAIResponse> {\n  try {\n    // Use the provided API key or fall back to the hardcoded one\n    const effectiveApiKey = apiKey.trim() || HARDCODED_API_KEY;\n    \n    // OpenAI API endpoint for GPT-4 Vision\n    const endpoint = 'https://api.openai.com/v1/chat/completions';\n    \n    // Get the prompt for icon synonyms\n    const prompt = getIconSynonymsPrompt(iconData.name, iconData.existingDescription);\n    \n    // Prepare the request payload\n    const payload = {\n      model: \"gpt-4o\",\n      messages: [\n        {\n          role: \"user\",\n          content: [\n            { type: \"text\", text: prompt },\n            {\n              type: \"image_url\",\n              image_url: {\n                url: `data:image/png;base64,${iconData.imageBase64}`\n              }\n            }\n          ]\n        }\n      ],\n      max_tokens: 300\n    };\n    \n    // Log the final message being sent to OpenAI (excluding the image data for brevity)\n    console.log(\"Sending to OpenAI:\", {\n      model: payload.model,\n      messages: [\n        {\n          role: \"user\",\n          content: [\n            { type: \"text\", text: prompt },\n            { type: \"image_url\", image_url: { url: \"[BASE64_IMAGE_DATA]\" } }\n          ]\n        }\n      ],\n      max_tokens: payload.max_tokens\n    });\n    \n    // Make the API request\n    const response = await fetch(endpoint, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${effectiveApiKey}`\n      },\n      body: JSON.stringify(payload)\n    });\n    \n    // Parse the response\n    const data = await response.json();\n    \n    if (!response.ok) {\n      throw new Error(data.error?.message || 'Unknown error from OpenAI API');\n    }\n    \n    // Extract the synonyms from the response\n    const content = data.choices[0].message.content;\n    \n    // Log the response from OpenAI\n    console.log(\"Response from OpenAI:\", content);\n    \n    // Parse the JSON array from the response\n    try {\n      const synonyms = JSON.parse(content);\n      return { synonyms };\n    } catch (parseError) {\n      // If parsing fails, try to extract an array from the text\n      // Using a regular expression without the 's' flag for compatibility\n      const matches = content.match(/\\[([\\s\\S]*)\\]/);\n      if (matches && matches[1]) {\n        try {\n          const synonyms = JSON.parse(`[${matches[1]}]`);\n          return { synonyms };\n        } catch (e) {\n          throw new Error('Failed to parse synonyms from response');\n        }\n      } else {\n        throw new Error('Response format not recognized');\n      }\n    }\n  } catch (error: any) {\n    console.error('Error generating synonyms:', error);\n    return {\n      synonyms: [],\n      error: error.message || 'Unknown error occurred'\n    };\n  }\n} ", "// This plugin generates AI-powered synonyms for icon components\nimport { exportNodeAsBase64, getBestNodeToExport } from './src/icon-exporter';\nimport { generateSynonyms } from './src/ai-service';\nimport { showUI } from '@create-figma-plugin/utilities'\nimport { MessageToPlugin, ComponentInfo, SynonymGroup } from './src/types'\n\n// Show UI with increased size for the new functionality\nfigma.showUI(__html__, { width: 400, height: 500, themeColors: true });\n\ninterface DescriptionMessage {\n  type: 'update-description';\n  name: string;\n  description: string;\n  nodeType: string;\n  hasDescription: boolean;\n}\n\ninterface UpdateDescriptionMessage {\n  type: 'update-description';\n  description: string;\n}\n\ninterface DescriptionUpdatedMessage {\n  type: 'description-updated';\n  description: string;\n  hasDescription: boolean;\n}\n\ninterface GenerateSynonymsMessage {\n  type: 'generate-synonyms';\n  apiKey: string;\n}\n\ninterface SynonymsResultMessage {\n  type: 'synonyms-result';\n  synonyms: string[];\n  error?: string;\n}\n\ninterface UiReadyMessage {\n  type: 'ui-ready';\n}\n\ninterface CloseMessage {\n  type: 'close';\n}\n\ntype Message = \n  | DescriptionMessage \n  | UpdateDescriptionMessage \n  | GenerateSynonymsMessage \n  | SynonymsResultMessage \n  | UiReadyMessage\n  | CloseMessage;\n\nfunction updateDescription(node: ComponentNode | ComponentSetNode, description: string) {\n  node.description = description;\n  // Send updated description back to UI\n  figma.ui.postMessage({\n    type: \"description-updated\",\n    description: node.description,\n    hasDescription: node.description.trim() !== \"\"\n  } as DescriptionUpdatedMessage);\n}\n\n// Function to send current selection to UI\nfunction sendSelectionToUI() {\n  const selection = figma.currentPage.selection;\n  \n  if (selection.length === 1) {\n    const node = selection[0];\n    \n    if (node.type === \"COMPONENT\" || node.type === \"COMPONENT_SET\" || node.type === \"INSTANCE\") {\n      const hasDescription = Boolean(\n        node.type === \"INSTANCE\" \n          ? node.mainComponent?.description \n          : node.description\n      );\n      \n      const description = node.type === \"INSTANCE\"\n        ? node.mainComponent?.description || \"\"\n        : node.description || \"\";\n      \n      figma.ui.postMessage({\n        type: \"SELECTION_CHANGE\",\n        component: {\n          name: node.name,\n          type: node.type,\n          description,\n          hasDescription\n        }\n      });\n    }\n  }\n}\n\n// Handle messages from the UI\nfigma.ui.onmessage = async (msg: MessageToPlugin) => {\n  if (msg.type === 'GENERATE_SYNONYMS') {\n    try {\n      // Show loading state\n      figma.notify(\"Generating synonyms...\");\n      \n      // Get the current selection\n      const selection = figma.currentPage.selection;\n      \n      // Find the best node to export\n      const nodeToExport = getBestNodeToExport(selection);\n      \n      if (!nodeToExport) {\n        figma.ui.postMessage({\n          type: 'synonyms-result',\n          synonyms: [],\n          error: 'No valid icon selected'\n        });\n        return;\n      }\n      \n      // Export the node as base64\n      const imageBase64 = await exportNodeAsBase64(nodeToExport);\n      \n      // Get the node name and description\n      let name = nodeToExport.name;\n      let description = '';\n      \n      if (nodeToExport.type === 'COMPONENT') {\n        description = nodeToExport.description || '';\n      } else if (nodeToExport.type === 'INSTANCE' && nodeToExport.mainComponent) {\n        description = nodeToExport.mainComponent.description || '';\n      }\n      \n      // Generate synonyms using the AI service\n      const result = await generateSynonyms({\n        name,\n        imageBase64,\n        existingDescription: description\n      }, msg.apiKey);\n      \n      // Send the result back to the UI\n      figma.ui.postMessage({\n        type: 'synonyms-result',\n        synonyms: result.synonyms,\n        error: result.error\n      });\n      \n      if (result.error) {\n        figma.notify(\"Error generating synonyms: \" + result.error);\n      } else {\n        figma.notify(\"Synonyms generated successfully!\");\n      }\n    } catch (error: any) {\n      console.error('Error in generate-synonyms handler:', error);\n      figma.ui.postMessage({\n        type: 'synonyms-result',\n        synonyms: [],\n        error: error.message || 'Unknown error occurred'\n      });\n      figma.notify(\"Error generating synonyms\");\n    }\n  } else if (msg.type === 'UPDATE_DESCRIPTION') {\n    const selection = figma.currentPage.selection[0];\n    if (selection && (selection.type === \"COMPONENT\" || selection.type === \"COMPONENT_SET\")) {\n      try {\n        selection.description = msg.synonyms.join(', ');\n        figma.notify('Description updated successfully!');\n      } catch (error) {\n        figma.ui.postMessage({\n          type: 'GENERATE_ERROR',\n          error: 'Failed to update description: ' + error.message\n        });\n      }\n    }\n  } else if (msg.type === 'close') {\n    figma.closePlugin();\n  } else if (msg.type === 'ui-ready') {\n    console.log(\"UI is ready, sending current selection\");\n    sendSelectionToUI();\n  }\n};\n\n// Listen for selection changes\nfigma.on(\"selectionchange\", () => {\n  sendSelectionToUI();\n});\n\n// Initial selection check\nsendSelectionToUI();\n"],
  "mappings": "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",
  "names": []
}
